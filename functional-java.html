<!DOCTYPE html>
<html>
<head>
    <title>Guide to Learning Functional Java</title>
</head>
<body>
    <h1>Introduction to Functional Java</h1>
    <p>Functional programming is a paradigm that treats computation as the evaluation of mathematical functions and avoids changing state and mutable data. Java has adopted many functional programming features starting from Java 8, making it easier to write clean, concise, and efficient code.</p>
    
    <h2>Key Concepts</h2>
    <ol>
        <li><strong>Pure Functions</strong>: Functions that always produce the same output for the same input and have no side effects.</li>
        <li><strong>Immutability</strong>: Data cannot be modified after it is created.</li>
        <li><strong>Higher-Order Functions</strong>: Functions that can take other functions as arguments or return them as results.</li>
        <li><strong>Function Composition</strong>: Combining simple functions to build more complex ones.</li>
        <li><strong>Lambda Expressions</strong>: A way to create anonymous functions in a concise way.</li>
        <li><strong>Streams</strong>: A sequence of elements supporting sequential and parallel aggregate operations.</li>
    </ol>
    
    <h2>Lambda Expressions</h2>
    <h3>Syntax</h3>
    <pre><code>(parameters) -> expression
(parameters) -> { statements; }</code></pre>
    
    <h3>Example</h3>
    <pre><code>// Traditional way
Runnable r1 = new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello World!");
    }
};

// Using lambda expression
Runnable r2 = () -> System.out.println("Hello World!");</code></pre>
    
    <h2>Functional Interfaces</h2>
    <p>A functional interface is an interface with a single abstract method, which can be implemented using a lambda expression.</p>
    
    <h3>Common Functional Interfaces</h3>
    <ul>
        <li><code>Predicate&lt;T&gt;</code>: Represents a boolean-valued function of one argument.</li>
        <li><code>Function&lt;T, R&gt;</code>: Represents a function that accepts one argument and produces a result.</li>
        <li><code>Supplier&lt;T&gt;</code>: Represents a supplier of results.</li>
        <li><code>Consumer&lt;T&gt;</code>: Represents an operation that accepts a single input argument and returns no result.</li>
        <li><code>BiFunction&lt;T, U, R&gt;</code>: Represents a function that accepts two arguments and produces a result.</li>
    </ul>
    
    <h3>Example</h3>
    <pre><code>// Predicate
Predicate&lt;String&gt; isEmpty = String::isEmpty;

// Function
Function&lt;String, Integer&gt; stringLength = String::length;

// Supplier
Supplier&lt;String&gt; stringSupplier = () -> "Hello";

// Consumer
Consumer&lt;String&gt; print = System.out::println;

// BiFunction
BiFunction&lt;Integer, Integer, Integer&gt; add = (a, b) -> a + b;</code></pre>
    
    <h2>Streams API</h2>
    <p>Streams allow you to process sequences of elements declaratively and in parallel.</p>
    
    <h3>Creating Streams</h3>
    <pre><code>// From a collection
List&lt;String&gt; list = Arrays.asList("a", "b", "c");
Stream&lt;String&gt; stream = list.stream();

// From an array
Stream&lt;String&gt; stream = Stream.of("a", "b", "c");

// From values
Stream&lt;String&gt; stream = Stream.of("a", "b", "c");</code></pre>
    
    <h3>Stream Operations</h3>
    <ul>
        <li><strong>Intermediate Operations</strong>: Return a new stream.
            <ul>
                <li><code>filter</code>: Filters elements based on a predicate.</li>
                <li><code>map</code>: Transforms each element.</li>
                <li><code>flatMap</code>: Flattens nested structures.</li>
            </ul>
        </li>
        <li><strong>Terminal Operations</strong>: Produce a result or side-effect.
            <ul>
                <li><code>forEach</code>: Performs an action for each element.</li>
                <li><code>collect</code>: Converts the stream into a collection.</li>
                <li><code>reduce</code>: Reduces the elements to a single value.</li>
            </ul>
        </li>
    </ul>
    
    <h3>Example</h3>
    <pre><code>List&lt;String&gt; list = Arrays.asList("a", "b", "c", "", "d", "e");

List&lt;String&gt; result = list.stream()
                          .filter(s -> !s.isEmpty())
                          .map(String::toUpperCase)
                          .collect(Collectors.toList());</code></pre>
    
    <h2>Optional</h2>
    <p>Optional is a container object which may or may not contain a non-null value.</p>
    
    <h3>Creating Optionals</h3>
    <pre><code>Optional&lt;String&gt; optional = Optional.of("value");
Optional&lt;String&gt; emptyOptional = Optional.empty();
Optional&lt;String&gt; nullableOptional = Optional.ofNullable(null);</code></pre>
    
    <h3>Using Optionals</h3>
    <pre><code>Optional&lt;String&gt; optional = Optional.of("value");

optional.ifPresent(System.out::println);

String result = optional.orElse("default");

optional.map(String::toUpperCase)
        .orElseThrow(IllegalArgumentException::new);</code></pre>
    
    <h2>Best Practices</h2>
    <ol>
        <li><strong>Prefer Immutability</strong>: Use immutable data structures wherever possible.</li>
        <li><strong>Use Pure Functions</strong>: Aim to write pure functions to avoid side effects.</li>
        <li><strong>Leverage Streams</strong>: Use the Streams API for concise and readable data processing.</li>
        <li><strong>Handle Nulls with Optionals</strong>: Use <code>Optional</code> to handle potential null values safely.</li>
        <li><strong>Use Functional Interfaces and Lambdas</strong>: Write cleaner and more expressive code with lambdas and functional interfaces.</li>
    </ol>
    
    <h2>Learning Resources</h2>
    <ol>
        <li><strong>Documentation</strong>: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html">Java Functional Programming Documentation</a></li>
        <li><strong>Books</strong>: "Java 8 in Action" by Raoul-Gabriel Urma, Mario Fusco, and Alan Mycroft.</li>
        <li><strong>Online Courses</strong>: Platforms like Coursera, Udemy, and Pluralsight.</li>
        <li><strong>Interactive Tutorials</strong>: <a href="https://www.baeldung.com/java-8-new-features">Baeldung Java 8 Guide</a></li>
    </ol>
    
    <h2>Practice</h2>
    <ol>
        <li>Refactor existing code to use functional programming principles.</li>
        <li>Create small projects that utilize Streams and Optionals.</li>
        <li>Participate in coding challenges focused on functional programming.</li>
    </ol>
    
    <p>This guide provides a solid foundation for beginners to start learning and using functional programming in Java effectively. Encourage newcomers to practice regularly and explore advanced features as they become more comfortable with the basics.</p>
</body>
</html>